/*[toml]
[dependencies]
thag_styling = { version = "0.2, thag-auto" }

[features]
default = ["thag_styling/color_detect"]
*/

/// Debug ANSI code generation and parsing
///
/// This script helps debug how ANSI codes are generated by the styling system
/// and tests the parsing logic for detecting attributes in ANSI sequences.
//# Purpose: Debug ANSI code generation and attribute detection
//# Categories: styling, debugging, testing
use thag_styling::{ColorInitStrategy, Role, Styleable, Styler, TermAttributes};

fn main() {
    // Initialize styling system
    TermAttributes::initialize(&ColorInitStrategy::Match);

    println!("=== ANSI Code Generation and Parsing Debug ===\n");

    // Test 1: See what ANSI codes are generated for different styles
    println!("1. ANSI code generation:");

    let plain_text = "plain";
    let bold_text = plain_text.normal().bold();
    let italic_text = plain_text.normal().italic();
    let underline_text = plain_text.normal().underline();
    let combined_text = plain_text.normal().bold().italic().underline();
    let colored_text = plain_text.error();
    let colored_bold_text = plain_text.error().bold();

    println!("   Plain: {:?}", plain_text);
    println!("   Bold: {:?}", bold_text.to_string());
    println!("   Italic: {:?}", italic_text.to_string());
    println!("   Underline: {:?}", underline_text.to_string());
    println!("   Combined (B+I+U): {:?}", combined_text.to_string());
    println!("   Colored (Error): {:?}", colored_text.to_string());
    println!("   Colored + Bold: {:?}", colored_bold_text.to_string());
    println!();

    // Test 2: Test the actual problem - attribute leakage
    println!("2. Attribute leakage test:");
    let inner_bold = "INNER".normal().bold();
    let outer_result = format!("outer {inner_bold} outer").info();

    println!("   Inner bold: {:?}", inner_bold.to_string());
    println!("   Final result: {:?}", outer_result.to_string());
    println!("   Rendered: {}", outer_result);

    // Manual inspection of what should happen:
    // 1. inner_bold should generate something like "\x1b[1mINNER\x1b[0m"
    // 2. The format! creates "outer \x1b[1mINNER\x1b[0m outer"
    // 3. outer_result.info() should wrap this and replace \x1b[0m
    // 4. If our fix works, the reset should include \x1b[22m to turn off bold

    println!();

    // Test 3: Multiple levels of nesting
    println!("3. Multi-level nesting:");
    let level2 = "L2".normal().italic();
    let level1 = format!("L1 {level2} L1").warning().bold();
    let level0 = format!("L0 {level1} L0").success();

    println!("   Level 2 (italic): {:?}", level2.to_string());
    println!("   Level 1 (bold): {:?}", level1.to_string());
    println!("   Level 0 (normal): {:?}", level0.to_string());
    println!("   Final rendered: {}", level0);
    println!();

    // Test 4: Show raw ANSI sequences to understand structure
    println!("4. Raw ANSI sequence analysis:");
    let test_bold = "test".normal().bold();
    let test_with_bold = format!("before {test_bold} after").error();

    let bold_str = test_bold.to_string();
    let final_str = test_with_bold.to_string();

    println!(
        "   Bold string raw: {}",
        bold_str
            .chars()
            .map(|c| if c == '\x1b' {
                "\\x1b".to_string()
            } else {
                c.to_string()
            })
            .collect::<String>()
    );

    println!(
        "   Final string raw: {}",
        final_str
            .chars()
            .map(|c| if c == '\x1b' {
                "\\x1b".to_string()
            } else {
                c.to_string()
            })
            .collect::<String>()
    );

    println!("\n=== Analysis ===");
    println!("This debug output shows:");
    println!("1. How ANSI codes are generated by the styling system");
    println!("2. Whether reset replacement is working correctly");
    println!("3. The exact ANSI sequences being produced");
    println!("4. Whether attribute resets are being inserted properly");
}
