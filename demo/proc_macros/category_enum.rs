use proc_macro::TokenStream;
use quote::quote;
use std::str::FromStr;

pub fn category_enum_impl(_input: TokenStream) -> TokenStream {
    let expanded = quote! {
        use std::str::FromStr;

        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        enum Category {
            AST,
            CLI,
            REPL,
            Async,
            Basic,
            BigNumbers,
            Crates,
            Educational,
            ErrorHandling,
            Exploration,
            Macros,
            Math,
            ProcMacros,
            Prototype,
            Recreational,
            Reference,
            Technique,
            Testing,
            Tools,
            TypeIdentification,
        }

        impl FromStr for Category {
            type Err = String;

            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s.to_lowercase().as_str() {
                    "ast" => Ok(Category::AST),
                    "cli" => Ok(Category::CLI),
                    "repl" => Ok(Category::REPL),
                    "async" => Ok(Category::Async),
                    "basic" => Ok(Category::Basic),
                    "big_numbers" => Ok(Category::BigNumbers),
                    "crates" => Ok(Category::Crates),
                    "educational" => Ok(Category::Educational),
                    "error_handling" => Ok(Category::ErrorHandling),
                    "exploration" => Ok(Category::Exploration),
                    "macros" => Ok(Category::Macros),
                    "math" => Ok(Category::Math),
                    "proc_macros" => Ok(Category::ProcMacros),
                    "prototype" => Ok(Category::Prototype),
                    "recreational" => Ok(Category::Recreational),
                    "reference" => Ok(Category::Reference),
                    "technique" => Ok(Category::Technique),
                    "testing" => Ok(Category::Testing),
                    "tools" => Ok(Category::Tools),
                    "type_identification" => Ok(Category::TypeIdentification),
                    _ => Err(format!("Invalid category: {}", s)),
                }
            }
        }

        /// Returns a vector of all valid category names as strings.
        ///
        /// This function is automatically generated by the `category_enum` macro and provides
        /// a complete list of categories, making it convenient for validation, UI prompts, or filtering.
        ///
        /// # Example
        ///
        /// ```rust
        /// use demo_proc_macros::category_enum;
        ///
        /// category_enum! {
        ///     AST, CLI, REPL, async, basic, big_numbers, crates, educational,
        ///     error_handling, exploration, macros, math, proc_macros, prototype,
        ///     recreational, reference, technique, testing, tools, type_identification
        /// }
        ///
        /// let categories = Category::all_categories();
        /// assert_eq!(categories, vec![
        ///     "AST", "CLI", "REPL", "Async", "Basic", "BigNumbers", "Crates",
        ///     "Educational", "ErrorHandling", "Exploration", "Macros", "Math",
        ///     "ProcMacros", "Prototype", "Recreational", "Reference", "Technique",
        ///     "Testing", "Tools", "TypeIdentification"
        /// ]);
        /// ```
        pub fn all_categories() -> Vec<String> {
            vec![
                "AST".to_string(),
                "CLI".to_string(),
                "REPL".to_string(),
                "async".to_string(),
                "basic".to_string(),
                "big_numbers".to_string(),
                "crates".to_string(),
                "educational".to_string(),
                "error_handling".to_string(),
                "exploration".to_string(),
                "macros".to_string(),
                "math".to_string(),
                "proc_macros".to_string(),
                "prototype".to_string(),
                "recreational".to_string(),
                "reference".to_string(),
                "technique".to_string(),
                "testing".to_string(),
                "tools".to_string(),
                "type_identification".to_string(),
            ]
        }
    };
    TokenStream::from(expanded)
}
